	jmp 	_KERNEL
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2021.2
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor está no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_RESET:		equ	_VETTAB+H0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
		org		_IOAREA16
		daw		[31]
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		org		_IOAREA08
		dab		[23]
TIMDT:	db		0			; Registro de programação do timer
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
		org		_KERNEL
		jmp		_RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
		org		_VETTAB
		dw		_kbhit
		dw		_getchar
		dw		_putchar
		dw		_putmsg
		dw		_getclock
		dw		_setclock
		dw		_setalarm
		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
		org		_RESET
; 1) Desabilitar o sistema de interrupções
	
		clr INTS

; 2) Inicializar o stack pointer (SP = R6)

		mov #h8000, R6

; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)

		clr		INTS			; Reset pedidos de interrupcao

; 4) Inicializar as variáveis internas do kernel

		clr 	clock_sec
		clr 	clock_min
		clr 	clock_hor
		clr 	getchar_waiting

; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)

		clr 	TECST			; Reset estado do hardware do teclado

; 6) Inicializar o timer

		mov 	#250,TIMDT

; 7) Limpar o visor
	
		jsr 	clear_display, r7

; 8) Habilitar interrupções

		mov 	#h81,INTS

; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
		jmp		_APP

;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_kbhit:

		clr 	r0
		cmp 	TECST, #h80
		bne 	not_found
		inc 	r0
	not_found:
		rts		r7
		
;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_getchar:

		jsr		_kbhit
		tst 	r0
		bne		_getchar
		mov 	#1, getchar_waiting
		mov 	TECDT, r0
		rts		r7
		
;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_putchar:

		cmp 	r5, #h20
		blt 	symbol
		cmp 	r5, #h7A
		bgt 	error_putch
		mov 	r5, display_cursor
		jmp 	end_putch

	symbol:

		cmp 	r5, #h0D
		bne 	a_putchar
		mov 	#VISOR, display_cursor
		jmp 	end_putch

	a_putchar:

		cmp 	r5, #h0A
		bne 	b_putchar
		jsr 	clear_display, r7
		jmp 	end_putch

	b_putchar:

		cmp 	r5, #h08
		bne 	b_putchar
		dec 	display_cursor
		jmp 	end_putch

	error_putch:

		mov 	#1, r0

	end_putch:
		
		rts		r7

;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_putmsg:
		rts		r7
	
;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_getclock:

		mov 	clock_hor, r2
		mov 	clock_min, r1
		mov 	clock_sec, r0
		rts		r7
		
;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_setclock:
; r0 = 1 : error in second
; r0 = 2 : error in minute
; r0 = 3 : error in hour 
		
		cmp 	r3, #60
		blt		sec_not_error
		mov 	#1, r0
		jmp 	end

	sec_not_error:
		mov 	r3, clock_sec

		cmp 	r4, #60
		blt		min_not_error
		mov  	#2, r0
		jmp 	end

	min_not_error:
		mov 	r4, clock_min
	
		cmp 	r5, #24
		blt		hor_not_error
		mov 	#3, r0
		jmp 	end

	hor_not_error:
		mov 	r5, clock_hor

	end:

		rts		r7
		
;		
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
_setalarm:

; r0 = 1 : error in second
; r0 = 2 : error in minute
; r0 = 3 : error in hour 
		
		cmp 	r2, #60
		blt		sec_not_error_a
		mov 	#1, r0
		jmp 	end_alarm

	sec_not_error_a:
		mov 	r2, clock_sec

		cmp 	r3, #60
		blt		min_not_error_a
		mov  	#2, r0
		jmp 	end_alarm

	min_not_error_a:
		mov 	r3, clock_min
	
		cmp 	r5, #24
		blt		hor_not_error
		mov 	#3, r0
		jmp 	end_alarm

	hor_not_error_a:
		mov 	r5, clock_hor

	end_alarm:

		rts		r7


getchar_waiting	: 	dw 0
clock_hor		:	dw 0
clock_min		:	dw 0
clock_sec 		: 	dw 0
display_cursor 	: 	dw 0
alarm_hor		:	dw 0
alarm_min		:	dw 0
alarm_sec 		: 	dw 0

_display_clock:

	

		mov 	r4, -(r6)
		mov 	r5, -(r6)

		clr 	r4
		mov 	#-1, r5
	display_clock_loop1:
		inc 	r5
		add 	#10, r4
		cmp 	r4, clock_hor
		blt		display_clock_loop1

		add 	r5, #H30
		mov 	r5, #28(VISOR)

		sub 	#10, r4
		mov 	clock_hor, r5
		sub 	r4, r5

		add 	r5, #H30
		mov 	r5, #29(VISOR)

		mov 	#H3A, #30(VISOR)


		clr 	r4
		mov 	#-1, r5
	display_clock_loop2:
		inc 	r5
		add 	#10, r4
		cmp 	r4, clock_min
		blt		display_clock_loop2

		add 	r5, #H31
		mov 	r5, #32(VISOR)

		sub 	#10, r4
		mov 	clock_min, r5
		sub 	r4, r5

		add 	r5, #H30
		mov 	r5, #32(VISOR)


		mov 	#H3A, #33(VISOR)


	clr 	r4
		mov 	#-1, r5
	display_clock_loop3:
		inc 	r5
		add 	#10, r4
		cmp 	r4, clock_sec
		blt		display_clock_loop3

		add 	r5, #H30
		mov 	r5, #34(VISOR)

		sub 	#10, r4
		mov 	clock_sec, r5
		sub 	r4, r5

		add 	r5, #H30
		mov 	r5, #35(VISOR)

		rts 	r7

		



clear_display:
		mov 	r0, -(r6)
		mov 	#31,r0
	clear_display_a:
		clr 	(VISOR(r0))
		sob 	r0, clear_display_a
		mov 	(r6)+, r0
		rts 	r7


org _APP

		jsr 	_display_clock, r7
		jmp 	_APP
		